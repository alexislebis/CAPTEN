/**
 * An exploitable output is the identificaation of a subpart of a RGTE which will represents the sought
 * Knowledge, or reusable output.
 */

function ExploitableOutput(cptClass)
{
  CAPTENClass.call(this);

  if(!cptClass instanceof CAPTENClass)
    return;

    //REBUILD from the CAPTENClass
  if(cptClass)
  {
   this.uri = cptClass.uri;
   this.properties = cptClass.properties;

   this.isBlank = cptClass.isBlank;

   //Dynamic inheritance system. CF Property for more details
   this.iName = "ExploitableOutput";
   this.label = cptClass.label;
   this.inheritanceArray = cptClass.inheritanceArray;
   this.subClasses = cptClass.subClasses; //Here are the classes which inherit this
   this.subClassOf = cptClass.subClassOf; //Here, the classes inherited from this

   // Keep a link with the instance of the same class which was used to produce this
   // copy function MUST DEFINE this.derivedFrom attribute.
     this.derivedFrom = cptClass;
   }

   //Private
    //this.exploitableOutput = null; //FIXME A sub RTE representing smthg can have subpart representing smth else, in a more atomic PoV
    //TODO REDO
    this.annotation = null;
      this.description = null; //TODO Temporary addendum. Redo

    this.exploitableOutputSummary = null;
    this.exploitableOutputTerminology = null;
    this.exploitationType = null;

    this.contextValidity = null;
      this.context = null;//TODO Temp. Redo with validity pov

    this.scientificStatement = null;//REVIEW little change applyed to the CAPTEN-ONTO ExplOut has directly scStamtents []
    this.IAP = null;

    this.htmlify = "an exploitable output";
}

    ExploitableOutput.prototype = new CAPTENClass();
    ExploitableOutput.prototype.constructor = ExploitableOutput;

    ExploitableOutput.prototype.setDescription = function(description)
    {
      if(description == null)
        return;

      if(description.id == null)
      {
        console.error('description must have an id');
        return null;
      }

      if(!(description instanceof Description))
      {
        console.error('description must be an Objective');
        return null;
      }

      var narrativeblock = null;
      if(this.description)//If a description already exist, it must be replaced
      {
        narrativeblock = NARRATIVE_BLOCK_POOL.getNarrativeBlockForID(this.id);

        if(narrativeblock == null)
        {
          console.log('A narrative block should be present. Aborting...');
          return;
        }

        narrativeblock.removeElement(this.description);
      }

      narrativeblock = NARRATIVE_BLOCK_POOL.getNarrativeBlockForID(this.id);
      if(narrativeblock == null)
      {
        console.log('Their is no narrative block registered for the element#'+this.id+' inside the narrative block pool. Registering...');
        narrativeblock = NARRATIVE_BLOCK_POOL.createFromElement(this);
        console.log('done. Registered in block#'+narrativeblock.id);
      }

      var props = PROPERTIES_POOL.getPropertiesByExtremities(this.id, description.id);
      var prop = null;

      if(props.length <= 0)
      {
        console.log('the relation between the step and the description is not referenced in the pool. Referencing...');
        prop = PROPERTIES_POOL.create(HAS_CONTEXT_URI,URI_TO_LABEL(HAS_CONTEXT_URI),this.id, description.id);
        console.log('done.');
      }
      else
        prop = props[0];

      console.log(narrativeblock);
      narrativeblock.addElement(description, prop);//Adding the new addendum inside the corresponding narrative block
        this.description = description;
    }

    ExploitableOutput.prototype.setContext = function(context)
    {
      if(context == null)
        return;

      if(context.id == null)
      {
        console.error('context must have an id');
        return null;
      }

      if(!(context instanceof Context))
      {
        console.error('context must be an Objective');
        return null;
      }

      var narrativeblock = null;
      if(this.context)//If a context already exist, it must be replaced
      {
        narrativeblock = NARRATIVE_BLOCK_POOL.getNarrativeBlockForID(this.id);

        if(narrativeblock == null)
        {
          console.log('A narrative block should be present. Aborting...');
          return;
        }

        narrativeblock.removeElement(this.context);
      }

      narrativeblock = NARRATIVE_BLOCK_POOL.getNarrativeBlockForID(this.id);
      if(narrativeblock == null)
      {
        console.log('Their is no narrative block registered for the element#'+this.id+' inside the narrative block pool. Registering...');
        narrativeblock = NARRATIVE_BLOCK_POOL.createFromElement(this);
        console.log('done. Registered in block#'+narrativeblock.id);
      }

      var props = PROPERTIES_POOL.getPropertiesByExtremities(this.id, context.id);
      var prop = null;

      if(props.length <= 0)
      {
        console.log('the relation between the step and the author is not referenced in the pool. Referencing...');
        prop = PROPERTIES_POOL.create(HAS_CONTEXT_URI,URI_TO_LABEL(HAS_CONTEXT_URI),this.id, context.id);
        console.log('done.');
      }
      else
        prop = props[0];

      console.log(narrativeblock);
      narrativeblock.addElement(context, prop);//Adding the new addendum inside the corresponding narrative block
        this.context = context;
        //ADD IN NARRATIVE BLOCK AND PROPERTU POOL HAS_CONTEXT
    }

    // === POLYMER ELEMENTS
      // === NAMER ELEMENT
      ExploitableOutput.namerElement = Polymer(
      {
        is : 'exploitable-output-namer-element',

        properties:
        {
          entity:
          {
            type: Object,
            notify: true,
          },
        },

        factoryImpl: function(item)
        {
          this.entity = item;
        },
      });
      // === END NAMER ELEMENT
      // === CONFIGURER ELEMENT
        ExploitableOutput.configurerElement =  Polymer(
        {
            is: "exploitable-output-configurer-element",

            properties:
            {
                entity:
                {
                    type: Object,
                    notify: true,
                    observer: "_updateField",
                },
                description:
                {
                    type: Object,
                    notify: true,
                    value: function(){return new Description();},
                },
                context:
                {
                    type: Object,
                    notify: true,
                    value: function(){return new Context();},
                },
                cascaded:
                {
                  type: Boolean,
                  notify: true,
                  value: false,
                },
            },

            factoryImpl: function(item)
            {
              this.entity = item;
            },

            _update: function(e)
            {
              if(this.entity == null)
                return;

              this.$.descriptionConfigurer._update();
              if( !IS_EMPTY(this.description))
                this.entity.setDescription(this.description);

              this.$.contextConfigurer._update();
                if(!IS_EMPTY(this.context))
                  this.entity.setContext(this.context);

              if(!this.cascaded)
                CONFIGURER_NOTIFY_VALIDATION_SIGNAL_BUILDER(this, this.entity, e);
            },
            _updateField: function()
            {
              if(this.entity == null)
                return;

              if(this.entity.description)
                  this.description = this.entity.description;

              if(this.entity.context)
                this.context = this.entity.context;
            },
        });
      // === END CONFIGURER ELEMENT
