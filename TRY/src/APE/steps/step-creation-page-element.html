<link rel="import" href="../operation-step-display-element.html">
<link rel="import" href="./step-status-displayer-element.html">
<link rel="import" href="./step-relation-tab-element.html">

<dom-module id="step-creation-page-element">
  <template>
    <style>
      :host{
        --rgte-common-width: 100%;
        --vis-element-width: 100%;
      }

      #vaadinOperation{
        min-height: 800px;
      }

      #commonInfo{
        width: 60%;
        margin: 0 auto;
        background-color: DodgerBlue;

      }

      #commonInfo > header{
        width: 100%;
        text-align: center;
        margin-bottom: 100px;
      }

      #separator{
        width: 95%;
        margin: 50px auto;
        border-bottom: 1px solid black;
      }

      #configurationZone{
        width: 100%;
      }

      #configurationZone > header{
        text-align: center;
      }

      #linkingZone
      {
        width: 100%;
        text-align: center;
      }

      #linkingZone > paper-fab{
        margin: 0 auto -10px auto;
      }


    </style>

<app-route route="{{route}}" pattern="/:itemValue" active="{{active}}" data="{{data}}" tail="{{tail}}"></app-route>

<div id="divRoot">

  <div id="commonInfo">
    <header>
      <h2> <span hidden$={{!isNew}}>New </span>Step</h2>
      <div id="paperFabs">
        <!-- <paper-fab icon="av:fiber-new" disabled="{{isNew}}" on-click="_openVocabularyNewItemPage"></paper-fab> -->

      </div>
      <paper-input id="nameNOP" label="Narrated operator name" value="{{stepName}}" char-counter required maxlength="100"></paper-input>
    </header>

    <div id="narrativeInfo">
      <div id="generalInformation">
        <header>
          <h4>General Information</h4>
        </header>
        <div id="gIContent" class="narrativeContent">
          <paper-input id="objectif1Step" label="The step's objective (#1)" value="{{stepobjectif1}}" char-counter maxlength="100"></paper-input>
        </div>
      </div>
      <div id="otherNarrative">
        <header>
          <h4>Other Narrative Information</h4>
        </header>
        <div id="oNIContent" class="narrativeContent">
          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris varius, est id ultrices lobortis, magna dolor aliquet ligula, non mollis augue turpis in nulla. Donec sit amet dui ornare, tempus nibh nec, pharetra tellus. Aliquam metus ex, convallis a tincidunt nec, tempus sit amet quam. Nullam at pellentesque tellus. Ut sollicitudin maximus lorem ac porttitor. Vivamus fringilla viverra nisl ut ultrices. Morbi aliquet sem lectus, sed malesuada velit facilisis sit amet. Donec volutpat, nunc quis ultrices aliquam, velit ante convallis purus, et malesuada mauris est accumsan magna. Vivamus nec nibh non arcu finibus posuere sed eget turpis. Interdum et malesuada fames ac ante ipsum primis in faucibus.
        </div>
      </div>
    </div>

  </div>

  <div id="separator"></div>

  <div id="configurationZone">

<!-- CONFIGURATION ZONE  -->

    <header>
      <h4>Representation of its behavior<br/>(How it is supposed to work in a general way)</h4>
    </header>

    <!-- <div id="stepState">
      <h3 id="stateTitle">Step State</h3>
      <div id="stepStateError">
        <div id="sSEHead">
          <h4 class="title">Error to solve before completing the step</h4>
        </div>
        <div id="sSESubDiv">
        </div>
      </div>
      <div id="stepStateLinking">
        <div id="sSLHead">
          <h4 class="title">@removeInputs concepts to Operator linkage</h4>
        </div>
        <div id="sSLSubDiv">

        </div>
      </div>
      <div id="identifK">
        <h4 class="title">@removeIdentify knowledge concepts</h4>
        <paper-fab id="kFab" icon="image:brush" on-tap="_toggleKnowledgeIdentification">
      </div>


    </div> -->

    <div id="linkingZone">
      <paper-fab icon="icons:settings-input-component" active="[[relationModeI_NOP]]" disabled$="{{_isLinkingDisabled(input, operation)}}" on-click="_toggleRelationMode"></paper-fab>
      <p hidden$="{{relationModeI_NOP}}">Bind your concepts with the input operator pattern</p>
      <p hidden$="{{!relationModeI_NOP}}">Click on a node within your concept and on a node within the input operator pattern for binding them</p>
    </div>

    <vaadin-split-layout>
      <vaadin-split-layout>
        <div>
          <h2>Input</h2>
          <neon-animated-pages selected='{{inputSection}}'
                           attr-for-selected='name'
                           entry-animation='scale-up-animation'
                           exit-animation='slide-right-animation'>

             <neon-animatable name='searchInput'><rgte-search-element id="rsei" enable-rewind="{{_computeRewindAuthorized(input)}}" enable-use="true"></rgte-search-element></neon-animatable>
             <neon-animatable name='inputZone'><rgte-workzone-element id="rwei" rgte="{{input}}" colorization="{{inputsColor}}" disable-edit disable-search disable-knowledge vocab="{{vocab}}" customcls="{{customcls}}" customprops="{{customprops}}"></rgte-workzone-element></neon-animatable>

          </neon-animated-pages>

        </div>
        <div id="vaadinOperation">
          <h2>Operation</h2>
          <neon-animated-pages selected='{{operationSection}}'
                           attr-for-selected='name'
                           entry-animation='scale-up-animation'
                           exit-animation='slide-right-animation'>

             <neon-animatable name='searchOperation'><operation-search-element id="ose" enable-rewind="{{_computeRewindAuthorized(operation)}}" enable-use="true"></operation-search-element></neon-animatable>
             <neon-animatable name='operationZone'><operation-step-display-element id="osde" colorization="{{operationInputsColor}}" operation="{{operation}}" vocab="{{vocab}}" customcls="{{customcls}}" customprops="{{customprops}}"></operation-step-display-element></neon-animatable>

          </neon-animated-pages>
        </div>
      </vaadin-split-layout>
        <div>
          <h2>Output</h2>
          <neon-animated-pages selected='{{outputSection}}'
                           attr-for-selected='name'
                           entry-animation='scale-up-animation'
                           exit-animation='slide-right-animation'>

             <neon-animatable name='outputZone'><rgte-workzone-element id="rweo" rgte="{{output}}" disable-edit disable-replace disable-search enable-launch vocab="{{vocab}}" customcls="{{customcls}}" customprops="{{customprops}}"></rgte-workzone-element></operation-search-element></neon-animatable>
             <neon-animatable name='stepStateZone'><step-status-displayer-element id="ssde" step="{{step}}"></step-status-displayer-element></neon-animatable>

          </neon-animated-pages>

        </div>
    </vaadin-split-layout>

    <div id="graphsRelations">
      <step-relation-tab-element composites="{{compositeIOP}}"></step-relation-tab-element>
      Tableau de relations ici.
      Intégrer les relations avec les éléments narratifs.
      Rajouter un color picker à la fin de la ligne.
    </div>

<!-- END CONFIGURATION ZONE  -->

  </div>
</div>
  </template>
  <script>
    Polymer(
    {
      is:"step-creation-page-element",


      properties:
      {
        route:
        {
          type: Object,
          notify: true,
        },

        step:
        {
          type: Object,
          value: function(){return new Step();},
          notify: true,
        },

        operation:
        {
          type: Object,
          notify: true,
        },

        input:
        {
          type: Object,
          notify: true,
        },

        output:
        {
          type: Object,
          notify: true,
        },

        compositeIOP:
        {
          type: Object,
          notify: true,
        },

        // === Graphs coloration
        inputsColor:
        {
          type: Array,
          notify: true,
          value: function(){return [];},
        },
        operationInputsColor:
        {
          type: Array,
          notify: true,
          value: function(){return [];},
        },

        // === Page
        operationSection:
        {
            type: String,
            value: "searchOperation",
            notify: true,
        },
        operationSectionStack: // Used to remember the user navigation. Usefull?
        {
          type: Array,
          value: function(){return [];},
          notify: true,
        },
        inputSection:
        {
          type: String,
          value: "searchInput",
          notify: true,
        },
        outputSection:
        {
          type: String,
          value: "stepStateZone",
          notify: true,
        },
        // === EndPage

        placeboOutput: //A placebo output used to reset the display and for prevent the useless creation of new tmp RGTE.
        { // DO NOT MODIFY ITS CONTENT
          type: Object,
          value: function(){return new RGTE();},
          notify: true,
        },

        relationModeI_NOP: //used for linking input with nop
        {
          type: Boolean,
          value: false,
          notify: true,
        },

        vocab:
        {
          type: Object,
          value: function(){ return new CONTROLLED_VOCABULARY();},
        },
        customcls://used for file-reader
        {
            type: Array,
            notify: true,
            value: function()
            {
                return [];
            },
        },
        customprops:
        {
            type: Array,
            notify: true,
            value: function()
            {
                return [];
            },
        },
      },

      observers: [
        "_onRouteChanged(route)",
        "_onColorChange(operationInputsColor.*)",
      ],

      _onColorChange: function()
      {
        console.log(this.operationInputsColor);
      },

      attached: function()
      {
        //@TODO  + deferencing into narrativeblock iff chang

        // === INPUT
        this.$.rsei.addEventListener(RGTE_USE_FROM_SEARCH_SIGNAL_ID, function(e){
          this._loadInputPage(e.detail.rgte);
        }.bind(this));

        this.$.rsei.addEventListener(RGTE_REWIND_REQUESTED_SIGNAL_ID, function(e)
        {
          this._loadInputPage(this.input);
        }.bind(this));

        this.$.rwei.addEventListener(RGTE_REPLACEMENT_REQUESTED_SIGNAL_ID, function(e){
          this._loadSearchInputPage();
        }.bind(this));

        this.$.rwei.addEventListener('NODE_CLICKED', function(e){
          this._behaviorManager(e.detail);
        }.bind(this));

        // === NOP
        this.$.ose.addEventListener(OPERATION_USE_FROM_SEARCH_SIGNAL_ID, function(e){
          this._loadOperationPage(e.detail.operation);
        }.bind(this));

        this.$.ose.addEventListener(OPERATION_REWIND_REQUESTED_SIGNAL_ID, function(e){
          this._loadOperationPage(this.operation);
        }.bind(this));

        this.$.osde.addEventListener(STEP_OPERATION_REPLACEMENT_REQUESTED_SIGNAL_ID, function(e){
          this._loadSearchOperationPage();
        }.bind(this));

        this.$.osde.addEventListener(OPERATION_INPUT_PATTERN_NODE_CLICKED_SIGNAL_ID, function(e){
          this._behaviorManager(e.detail);
        }.bind(this));


        // === OUTPUT
        this.step.registerObserverCallbackOnOutputsComputation(this, this._outputComputed);
        this.step.registerObserverCallbackOnOutputsReset(this, this._resetOutput);
        this.step.registerObserverCallbackOnUncompletion(this, this._uncompletedStep);
        this.step.registerObserverCallbackOnIOPCompositeRelationChange(this, this._changeOnCompositeIOP);
        this.step.registerObserverCallbackOnIOPCompositeOptionsChange(this, this._changeOnCompositeIOPOptions);

        // === LINKING FAB
        var i = this.operation;
        this.operation = null;
        this.operation = i; //Force redraw to actualise fab state

        // === RGTE_POOL
          // @TODO RGTE_POOL must notify on change. If the current input is not referenced anymore, delete it from input.
          // This is the case when the user use the output of a step as an input of the same step. The RGTE is deleted from the pool
          // but it always exist in step-creation-page-element.input and thus can be used; The step does not update *this* because
          // it is not linked (on page change we made a input = this.step.operator + retrieve the rgte for the research page)
      },

      // === RESET behaviors
      reset: function()
      {
        //todo reattacher listener sur nouvelle step
      },

      _behaviorManager: function(obj)
      {
        if(this.relationModeI_NOP)
        {
          this.step.bindRGTENOP(obj);
        }
        else // default behaviors : nothing to do
        {
          return;
        }
      },

    // === INPUT page
      _loadInputPage: function(rgte)
      {
        var oldInput = this.input;
        this.input = rgte;

        this.inputSection = "inputZone";

        if(this.input.id == oldInput.id)//if ident, no update for the step (prevent unregistering and recomputing of output)
          return;
        this.step.changeRGTE(this.input);
      },

      _loadSearchInputPage: function()
      {
        this.$.rsei.update();
        this.inputSection = "searchInput";
      },
    // === END Input Page
    // === NOP page Dedicated Function
      _loadOperationPage: function(operation)
      {
        this.operation = operation;
        this.step.changeOperator(this.operation);
        this.operationSection = "operationZone";
      },

      _loadSearchOperationPage: function()
      {
        this.operationSection = "searchOperation";
      },
    // === END NOP page Dedicated function

      _onRouteChanged: function(route)
      {
        if(route.prefix.toLowerCase() != "/step")
          return;

        this.$.rsei.update();
        this.$.ose.update();
        this.$.ssde.computeStepState();
      },

      _computeRewindAuthorized: function(operation)
      {
        return operation == null ? false : true;
      },

      _toggleRelationMode: function()
      {
        this.relationModeI_NOP = !this.relationModeI_NOP;
        return;
      },

      _uncompletedStep: function()
      {
        this.$.ssde.computeStepState();
      },

      _outputComputed: function()
      {
        this.output = this.step.outputs;
        this.outputSection = "outputZone";
      },

      _resetOutput: function()
      {
        this.output = this.placeboOutput;
        this.$.ssde.computeStepState();
        this.outputSection = "stepStateZone";

        // color reseting
        this.inputsColor = [];
        this.operationInputsColor = [];
      },

      _changeOnCompositeIOP: function()
      {
        this.compositeIOP = null;
        this.compositeIOP = this.step._compositeRelations;
      },

      _changeOnCompositeIOPOptions: function(elmt)
      {
        console.log("_changeOnCompositeIOPOptions: function(elmt)");
        console.log(elmt);

        if(elmt.options['color'] == null)
        {
          console.error("elmt.options['color'] is null.");
          return;
        }

        //@WARNING Strong dependencies with the Step model. It depends on the push order of the elements
        var idInput = elmt.elements[1].id;
        var idOpInput = elmt.elements[2].id;

        this.push("inputsColor", {id: elmt.elements[1].id, color: elmt.options['color']});
        this.push("operationInputsColor", {id: elmt.elements[2].id, color: elmt.options['color']});

        // this.input.getNodeById(idInput).color = elmt.options['color'];
        // this.$.rwei.notifyRGTEChange();
        //
        // this.operation.behaviors['input'].getNodeById(idOpInput).color = elmt.options['color'];
        // this.$.osde.refreshInputs();
      },

      _isLinkingDisabled: function(input, operation)
      {
        return (input == null || operation == null) ? true : false;
      },

    });
  </script>
</dom-module>
