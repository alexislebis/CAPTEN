<link rel="import" href="../../../import/zebra-import.html">
<!-- <link rel="import" href="../../../../../bower_components/iron-data-table/iron-data-table.html"> -->
<link rel="import" href="../../../../../bower_components/brainy-table/brainy-table.html">
<link rel="import" href="./htmlResponseBuilder.html">
<link rel="import" href="./tokensDisplayer.html">
<link rel="import" href="./tokenLister.html">
<link rel="import" href="./dimensionDisplayer.html">

<dom-module id="searching-according-need-element">
  <template>
    <style>

    </style>

    Dim = [Objectif,Need,Context]
    Describe Need <extended-paper-input-element id="need" vocab="{{vocab}}" customcls="{{customcls}}" customprops="{{customprops}}" label="Need description, N = (t1, t2,...,tn)" value="{{need}}" char-counter required></extended-paper-input-element>


      <p>degree validity by user</p>

      <template is="dom-if" if="{{fuzzyChecked}}" restamp="true">
        modificator
        <paper-dropdown-menu label="fuzzyModification" name="fuzzyModification" required>
            <paper-menu class="dropdown-content" id="fuzzyDropdown">
                <paper-item value="">No modificator</paper-item>
                <paper-item value="">Extremely</paper-item>
                <paper-item value="">Very</paper-item>
                <paper-item value="">Pretty</paper-item>
                <paper-item value="">Somewhat</paper-item>
                <paper-item value="">Badly</paper-item>
                <paper-item value="">Not</paper-item>
            </paper-menu>
        </paper-dropdown-menu>

        <paper-dropdown-menu label="typeOfSimilarity" name="typeOfSimilarity" required>
            <paper-menu class="dropdown-content" id="similarityDropdown">
                <paper-item value="">Similar</paper-item>
                <paper-item value="">Assimilable</paper-item>
                <paper-item value="">Approximating</paper-item>
                <paper-item value="">Alike</paper-item>
                <paper-item value="">Equivalent</paper-item>
                <paper-item value="">Identical</paper-item>
                <paper-item value="">Nearby</paper-item>
                <paper-item value="">Different</paper-item>
            </paper-menu>
        </paper-dropdown-menu>

        to my need description.

      </template>

    <h3>Matching behaviors</h3>
      <paper-checkbox checked="{{semanticChecked}}">Semantic matching</paper-checkbox>
      <paper-checkbox checked="{{fuzzyChecked}}">Fuzzy matching</paper-checkbox>


    <paper-button raised on-click="_startSearch">Let's match</paper-button>

    <h3>Result display</h3>

      <div id="result">

      </div>

        <!-- <iron-data-table items="[[resultArray]]">
          <data-table-column name="Token Answered" sort-by="item.nbTokenAns">
            <template>
              [[item.nbTokenAns]]/[[nbMaxToken]]
            </template>
          </data-table-column>
          <data-table-column name="ID">
            <template>[[item.id]]</template>
          </data-table-column>
          <data-table-column name="Type" filter-by="item.type">
            <template>[[item.type]]</template>
          </data-table-column>
        </iron-data-table> -->

        <paper-toggle-button id="togglePrio" checked="{{isPrio}}">Dimension priority option</paper-toggle-button>

        <ul>
          <template is="dom-if" if="{{isPrio}}">
            <li>
              <paper-dropdown-menu label="Token Priority" name="tokenPrio" required on-iron-select="_prioSelected">
                  <paper-menu class="dropdown-content" id="tokenPrio" selected="{{_computeSelectedPrio(item)}}">
                      <paper-item itemID="objective" prio$="{{TPV.VERY_HIGH}}">Very High</paper-item>
                      <paper-item itemID="objective" prio$="{{TPV.HIGH}}">High</paper-item>
                      <paper-item itemID="objective" prio$="{{TPV.NORMAL}}">Normal</paper-item>
                      <paper-item itemID="objective" prio$="{{TPV.LOW}}">Low</paper-item>
                      <paper-item itemID="objective" prio$="{{TPV.VERY_LOW}}">Very Low</paper-item>
                  </paper-menu>
              </paper-dropdown-menu>
              Objective
            </li>
          </template>

          <template is="dom-if" if="{{isPrio}}">
            <li>
              <paper-dropdown-menu label="Token Priority" name="tokenPrio" required on-iron-select="_prioSelected">
                  <paper-menu class="dropdown-content" id="tokenPrio" selected="{{_computeSelectedPrio(item)}}">
                      <paper-item itemID="context" prio$="{{TPV.VERY_HIGH}}">Very High</paper-item>
                      <paper-item itemID="context" prio$="{{TPV.HIGH}}">High</paper-item>
                      <paper-item itemID="context" prio$="{{TPV.NORMAL}}">Normal</paper-item>
                      <paper-item itemID="context" prio$="{{TPV.LOW}}">Low</paper-item>
                      <paper-item itemID="context" prio$="{{TPV.VERY_LOW}}">Very Low</paper-item>
                  </paper-menu>
              </paper-dropdown-menu>
              Context
            </li>
          </template>
        </ul>

        Full dimensions results
        <brainy-table id="a" items="[[combinedArray]]" page-size="7" details-enabled>
          <brainy-table-column name="Priority Score" filter-by="priorityScore" sort-by="priorityScore">
            <template>[[item.priorityScore]]</template>
          </brainy-table-column>
          <brainy-table-column name="Token coverage (#)" filter-by="nbTokenAns" sort-by="nbTokenAns">
            <!-- <template>[[_computeTokenCoverage(item.nbTokenAns)]]</template> -->
            <template>[[item.nbTokenAns]]</template>
          </brainy-table-column>
          <brainy-table-column name="ID" filter-by="id" sort-by="id">
            <template>[[item.id]]</template>
          </brainy-table-column>
          <brainy-table-column name="Name" filter-by="type" sort-by="type">
            <template>[[_computeName(item)]]</template>
          </brainy-table-column>
          <brainy-table-column name="Type" filter-by="type" sort-by="type">
            <template>[[item.type]]</template>
          </brainy-table-column>
          <brainy-table-column width="30px" align-right flex="0">
            <template>
              <template is="dom-if" if="[[!expanded]]">
                <iron-icon icon="icons:expand-more"></iron-icon>
              </template>
              <template is="dom-if" if="[[expanded]]">
                <iron-icon icon="icons:expand-less"></iron-icon>
              </template>
            </template>
          </brainy-table-column>
          <template is="row-detail">
            <div>
              <ul>
                <li>
                  <token-lister dimname="Objective" tok="{{item}}"></token-lister>
                </li>
                <li>
                  <token-lister dimname="Context" tok="{{item}}"></token-lister>
                </li>
              </ul>
            </div>
          </template>
          <div no-results>No results found. Perform a search before.</div>
        </brainy-table>

        <br/>
        <paper-toggle-button id="toggleDetail" checked="{{isShowDetail}}">Show details</paper-toggle-button>
        <br/>
        <br/>

        <div hidden$="{{!isShowDetail}}">
          <dimension-displayer id="objectiveDisplayer" name="Objective" result-array="{{objectiveRA}}" tokens-of-result="{{objectiveTOR}}" parent="{{objectiveRPR}}"></dimension-displayer>
          <dimension-displayer id="contextDisplayer" name="Context" result-array="{{contextRA}}" tokens-of-result="{{contextTOR}}" parent="{{contextRPR}}"></dimension-displayer>
        </div>
      <!-- <template id="bTable" is="dom-bind" result-array="{{resultArray}}" max-token="{{nbMaxToken}}"> -->

        <!-- <brainy-table id="a" items="[[resultArray]]" page-size="7" details-enabled>
          <brainy-table-column name="Priority Score" filter-by="priorityScore" sort-by="priorityScore">
            <template>[[item.priorityScore]]</template>
          </brainy-table-column>
          <brainy-table-column name="Token coverage (#)" filter-by="nbTokenAns" sort-by="nbTokenAns">
            <template>[[item.nbTokenAns]]</template>
          </brainy-table-column>
          <brainy-table-column name="ID" filter-by="id" sort-by="id">
            <template>[[item.id]]</template>
          </brainy-table-column>
          <brainy-table-column name="Type" filter-by="type" sort-by="type">
            <template>[[item.type]]</template>
          </brainy-table-column>
          <brainy-table-column width="30px" align-right flex="0">
            <template>
              <template is="dom-if" if="[[!expanded]]">
                <iron-icon icon="icons:expand-more"></iron-icon>
              </template>
              <template is="dom-if" if="[[expanded]]">
                <iron-icon icon="icons:expand-less"></iron-icon>
              </template>
            </template>
          </brainy-table-column>
          <template is="row-detail" bind="_testAttached">
            <div>
              <div id="resultDetail">
                <html-response-builder item="{{item}}" parent="{{resultOfParentRelevancy}}"></html-response-builder>
              </div>
              <paper-button raised on-click="_testClick">CLICK TO REQUERY</paper-button>
            </div>
          </template>
          <div no-results>No results found. Click here</div>
        </brainy-table> -->

      <!-- </template> -->

  </template>
  <script>
    Polymer({
      is: "searching-according-need-element",

      properties:
      {
        fuzzyChecked:
        {
          type: Boolean,
          value: true,
          notify: true,
        },

        semanticChecked:
        {
          type: Boolean,
          value: true,
          notify: true,
        },
        vocab:
        {
          type: Object,
        },
        customcls://used for file-reader
        {
            type: Array,
            notify: true,
        },
        customprops:
        {
            type: Array,
            notify: true,
        },
        need:
        {
          type: Object,//ExtendedString
          notify: true,
        },
        // resultArray:
        // {
        //   type: Array,
        //   notify: true,
        // },
        nbMaxToken:
        {
          type: Number,
          notify: true,
          value: 0,
        },

            objectiveRPR://old :resultOfParentRelevancy
            {
              type: Object,
              notify: true,
            },
            objectiveTOR: //old : tokensOfResult
            {
              type: Object,
              notify: true,
            },
            objectiveRA: //old: resultArray
            {
              type: Array,
              notify: true,
            },

            contextRPR://old :resultOfParentRelevancy
            {
              type: Object,
              notify: true,
            },
            contextTOR: //old : tokensOfResult
            {
              type: Object,
              notify: true,
            },
            contextRA: //old: resultArray
            {
              type: Array,
              notify: true,
            },


        expanded:
        {
          type: Boolean,
          notify: true,
          value: false,
        },
        engineResult:
        {
          type: Object,
          notify: true,
        },
        tokens:
        {
          type: Object,
          notify: true,
        },
        TPV:
        {
          type: Object,
          notify: true,
          value: function(){return DIMENSION_PRIORITY;},
        },
        combinedArray:
        {
          type: Array,
          notify: true,
        },
      },

      observers:
      [
        "_combinedArrayOnChange(combinedArray)",
      ],

      _combinedArrayOnChange: function(combinedArray)
      {

      },

      _testNBDim: function(item)
      {

      },

      attached: function()
      {
        this.$.objectiveDisplayer.addEventListener(DIMENSION_DISPLAYER_REQUIRE_UPDATE_SIGNAL_ID, function(e){
          // if(e.detail.DIM == "Objective")
          // {
            this._updateHTML("objectiveRPR", "objectiveTOR", "objectiveRA");
            this.updateObjectiveDimension();
          // }
          // else if(e.detail.DIM == "Context")
          // {

          // }
        }.bind(this));

        this.$.contextDisplayer.addEventListener(DIMENSION_DISPLAYER_REQUIRE_UPDATE_SIGNAL_ID, function(e){
          this._updateHTML("contextRPR", "contextTOR", "contextRA");
          this.updateContextDimension();
        }.bind(this));
      },


      _startSearch: function()
      {
        var mapDimTerms = [];
        // if(this.need && this.need.getString().length > 0)
        // {
        //   mapDimTerms["need"] = this.need.getSpecialElements();
        // }

        //TEST! ONLY FOR THE DIMENSION OBJECTIVE HERE
        if(!this.objectiveTOR)
          mapDimTerms["need"] = this._boostrapObjective();
        else
          mapDimTerms["need"] = this.objectiveTOR.tokens;

        if(!this.contextTOR)
          mapDimTerms["context"] = this._boostrapObjective();
        else
          mapDimTerms["context"] = this.contextTOR.tokens;
        // =======

        SEARCH_ENGINE.execute(mapDimTerms).then(
          function(resolve)
          {
            this.engineResult = resolve;
            this.objectiveRPR = this.engineResult['dimensions']["objective"]["result"];
            this.objectiveTOR = this.engineResult['dimensions']['objective'];
            this.objectiveRA  = [];

            this.contextRPR = this.engineResult['dimensions']['context']['result'];
            this.contextTOR = this.engineResult['dimensions']['context'];
            this.contextRA = [];
            // this.$.tokenDisplayer.update();
            this._updateHTML("objectiveRPR", "objectiveTOR", "objectiveRA");
            this._updateHTML("contextRPR", "contextTOR", "contextRA");

            this.updateDimensions();
          }.bind(this)
        );

        // if(!HYLAR_HANDLER.isReady())
        //   return;
        //
        // if(this.need && this.need.getString().length > 0)
        // {
        //   mapDimTerms["need"] = this.need.getSpecialElements();
        // }
        //
        // var result = this._defaultSearchBehavior(mapDimTerms);
      },

      _prioSelected: function(e)
      {
        var selectedPrioElmt = e.target.selectedItem;
        var selectedPrio = selectedPrioElmt.getAttribute("prio");
        var selectedItemID = selectedPrioElmt.getAttribute("itemID");

        if(!selectedPrio || !selectedItemID)
          return;

        if(selectedItemID == "objective")
          this.objectivePriority = selectedPrio;
        else if(selectedItemID == "context")
          this.contextPriority = selectedPrio;

        this._computeCombinedArray();
      },

      _boostrapObjective: function()
      {
        // ===============================================================
        // ==================         TEST        ========================
        // ===============================================================

        var need = [];

        // === TEST 1 : find smth working on Question Defaillante
          // var t1c1 = new CAPTENClass();
          // var t1c2 = new CAPTENClass();
          // t1c1.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/Proportion_de_Succes";
          // t1c2.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/QCM";
          //
          // need.push(t1c1);
          // need.push(t1c2);

        // === TEST 2 : Find an NarratedAnalysisProcess aiming to categorise a Apprenant (student)
          // var cl = new CAPTENClass();
          // cl.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/Etudiant";
          // var rel2 = new Property();
          // rel2.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/categorise";
          // rel2.from = ANALYSIS_URI;
          // rel2.to = "http://www.CAPTEN.org/SEED/ontologies/custom/Etudiant";
          //
          // var token1 = new Token(cl);
          // var token2 = new Token(rel2);
          //
          // need.push(token1);need.push(token2);
          // need.push(cl);
          // need.push(rel2);

        // === TEST 3 : Find a NarratedAnalysisProcess aiming to discover parcours made by students, where the parcours is supposed to be a pattern
          var t3r1 = new Property();
          var t3r2 = new Property();
          var t3r3 = new Property();

          t3r1.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/decouvre";
          t3r2.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/faitPar";
          t3r3.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/assimilableA";

          t3r1.from = ANALYSIS_URI;
          t3r2.from = "http://www.CAPTEN.org/SEED/ontologies/custom/Parcours";
          t3r3.from = "http://www.CAPTEN.org/SEED/ontologies/custom/Parcours";

          t3r1.to = "http://www.CAPTEN.org/SEED/ontologies/custom/Parcours";
          t3r2.to = "http://www.CAPTEN.org/SEED/ontologies/custom/Apprenant";
          t3r3.to = "http://www.CAPTEN.org/SEED/ontologies/custom/Pattern";

          SEARCH_ENGINE.TMP_SIMILARITY_INFO_REDO = "The property: http://www.CAPTEN.org/SEED/ontologies/custom/assimilableA is a special one. It implies similarity check between "+t3r3.from+" and "+t3r3.to + "<br/> Adding a property : ANALYSIS_URI http://www.CAPTEN.org/SEED/ontologies/custom/decouvre http://www.CAPTEN.org/SEED/ontologies/custom/Pattern" ;
          console.log("The property: <http://www.CAPTEN.org/SEED/ontologies/custom/assimilableA> is a special one. It implies similarity check between "+t3r3.from+" and "+t3r3.to);
          console.log("Adding a property : ANALYSIS_URI http://www.CAPTEN.org/SEED/ontologies/custom/decouvre http://www.CAPTEN.org/SEED/ontologies/custom/Pattern");
          t3r4 = new Property();
          t3r4.uri = "http://www.CAPTEN.org/SEED/ontologies/custom/decouvre";
          t3r4.from = ANALYSIS_URI;
          t3r4.to = "http://www.CAPTEN.org/SEED/ontologies/custom/Pattern";

          var token1 = new Token(t3r1);
          var token2 = new Token(t3r2);
          var token3 = new Token(t3r3);
          var token4 = new Token(t3r4);
          need.push(token1);need.push(token2);need.push(token3);need.push(token4);
          // need.push(t3r1); need.push(t3r2); need.push(t3r3); need.push(t3r4);

          return need;

        // ===============================================================
        // ==============         END TEST        ========================
        // ===============================================================
      },

      _updateHTML: function(resultOfParentRelevancy, tokenOfResults, resultArray)
      {
        var html = SEARCH_ENGINE.TMP_SIMILARITY_INFO_REDO + "<ul>";
        var tmpHtml = "";
        var otherReason = false;
        var analysisHTML = "";
        var otherHTML = "";
        var tmpNbToken = 0;
        var priorityScore = 0;

        // this._resetResultArray(resultArray);
        this[resultArray] = [];
        this.nbMaxToken = 0;

        for(var id in this[resultOfParentRelevancy])
        {
          // tmpHtml = "";
          // // if(resultOfParentRelevancy[id].type == ANALYSIS_URI)
          // // {
          //   tmpHtml += id +"(a "+resultOfParentRelevancy[id].type+") can be a solution because it solves exactly "+this._howManyTokensAnswered(resultOfParentRelevancy[id]).nb+" tokens ("+this._howManyTokensAnswered(resultOfParentRelevancy[id]).tokensID+") of your described need. ";
          //   tmpHtml += "<ul>";
          //
            tmpNbToken = 0;
            priorityScore = 0;
            for(var token in this[resultOfParentRelevancy][id])
            {
              if(token != "nbTokenAnswered" && token != "type")
              {
                tmpNbToken++;
                this.nbMaxToken++; console.error("TO HANDLE CORRECTLY");

                priorityScore += this._getPriorityTokenScore(this[resultOfParentRelevancy][id][token], this[tokenOfResults]);

                // tmpHtml += "<li>The token ("+token+") has been found:"
                // for(var typeMatching in resultOfParentRelevancy[id][token])
                // {
                //   if(typeMatching != "token")
                //   {
                //     tmpHtml += '<p>With a '+typeMatching+' matching:</p>';
                //     tmpHtml += "<ul>";
                //     for(var symbol in resultOfParentRelevancy[id][token][typeMatching])
                //     {
                //       tmpHtml += "<li>";
                //       if(symbol == "S")
                //         tmpHtml += this._constructHtmlOfStep(resultOfParentRelevancy, resultOfParentRelevancy[id][token][typeMatching][symbol], token, typeMatching);
                //       else
                //       {
                //         for(var element in resultOfParentRelevancy[id][token][typeMatching][symbol])
                //         {
                //           if(otherReason)
                //             tmpHtml += ", but also ";
                //
                //           tmpHtml += " in the "+this._symbolTrad(symbol)+" of "+id+" via "+resultOfParentRelevancy[id][token][typeMatching][symbol][element].current;
                //           otherReason = true;
                //         }
                //       }
                //
                //       otherReason = false;
                //       tmpHtml += "</li>";
                //     }
                //     tmpHtml += "</ul>";
                //   }
                // }
                // tmpHtml += "The token (0) has been found in the (knowledge) of "+id+"(, but also in its (name))".
                // tmpHtml += "The token 2 has been found in the (step) of "+id+", because in it, one graph contains the token".
                // tmpHtml += "</li>";
              }
            }

            this._updateResultArray(this[resultArray], tmpNbToken, id, this[resultOfParentRelevancy][id].type, priorityScore);

          //   tmpHtml += "</ul>";
          //
          //   if(resultOfParentRelevancy[id].type == ANALYSIS_URI)
          //     analysisHTML += "<li>"+tmpHtml+"</li>";
          //   else
          //     otherHTML += "<li>"+tmpHtml+"</li>";
          // // }


        }

        // html += "<h4>ANALYSIS</h4>"+ analysisHTML +"<h4>OTHER ELEMENTS</h4>"+ otherHTML + "</ul>";
        // var div = document.createElement('div');
        // div.innerHTML = html;
        // this.$$('#result').appendChild(div);
        // return html;

        // Hard notif
        // var tmp = resultArray;
        // resultArray = null;
        // resultArray = tmp;
      },

      updateDimensions: function()
      {
        this.updateObjectiveDimension();
        this.updateContextDimension();
      },

      updateObjectiveDimension: function()
      {
        var tmpObj = this.objectiveRA;
        this.objectiveRA = null;
        this.objectiveRA = tmpObj;

        this._computeCombinedArray();
      },

      updateContextDimension: function()
      {
        var tmpCtx = this.contextRA;
        this.contextRA = null;
        this.contextRA = tmpCtx;

        this._computeCombinedArray();
      },

      _computeName: function(item)
      {
        if(!item || !ID_CORRESPONDANCE[item.id])
          return "/";
        return ID_CORRESPONDANCE[item.id]+"";
      },

      _computeCombinedArray: function()
      {
          var newArray = []; //Array of nbTokensAns, priorityScore,  id, trueId, type

          for(var i in this.objectiveRA)
          {
            newArray.push({nbTokenAns: this.objectiveRA[i].nbTokenAns, nbTokenByDim: [], priorityScore: this.objectiveRA[i].priorityScore, id: this.objectiveRA[i].id, trueID: this.objectiveRA[i].trueID, type: this.objectiveRA[i].type});

            if(this.objectivePriority)
              newArray[newArray.length-1].priorityScore *= this.objectivePriority;
            else
              newArray[newArray.length-1].priorityScore *= DIMENSION_PRIORITY.NORMAL;

            newArray[newArray.length-1]["nbTokenByDim"]["objective"] = this._searchTokensAnsweredForInDim(newArray[newArray.length-1].trueID, this.objectiveRPR);
          }

          var add = [];
          var found = false;
          for(var j in this.contextRA)
          {
            found = false;
            for(var i in newArray)
            {
              if(this.contextRA[j].id == newArray[i].id)
              {
                newArray[i].nbTokenAns += this.contextRA[j].nbTokenAns;

                if(this.contextPriority)
                  newArray[i].priorityScore += this.contextRA[j].priorityScore * this.contextPriority;
                else
                  newArray[i].priorityScore += this.contextRA[j].priorityScore * DIMENSION_PRIORITY.NORMAL;

                newArray[i]["nbTokenByDim"]["context"]= this._searchTokensAnsweredForInDim(newArray[i].trueID, this.contextRPR);

                found = true;
                break;
              }
            }

            if(!found)
            {
              add.push({nbTokenAns: this.contextRA[j].nbTokenAns, nbTokenByDim: [], priorityScore: this.contextRA[j].priorityScore, id: this.contextRA[j].id, trueID: this.contextRA[j].trueID, type: this.contextRA[j].type});

              if(this.contextPriority)
                add[add.length-1].priorityScore *= this.contextPriority;
              else
                add[add.length-1].priorityScore *= DIMENSION_PRIORITY.NORMAL;

              add[add.length-1]["nbTokenByDim"]["context"] = this._searchTokensAnsweredForInDim(add[add.length-1].trueID, this.contextRPR);
            }
          }

          for(var i in add)
          {
            newArray.push(add[i]);
          }

          this.combinedArray = [];
          this.combinedArray = newArray;
      },

      _searchTokensAnsweredForInDim: function(id, where)
      {
        if(!where[id])
          return [];

        var tokenAnswered = [];

        for(var tokAns in where[id])
          if(tokAns != "type" && tokAns != "nbTokenAnswered")
            tokenAnswered.push(where[id][tokAns].token.token);

        return tokenAnswered;
      },

      _getPriorityTokenScore: function(token, tokenOfResults)//oldtokenRepresentation
      {
        var tokenTokenID = token.token.token.id;

        var prio = 0;
        var nbElm = 0;

        for(var i in tokenOfResults.tokens)
          if(tokenOfResults.tokens[i].token.id == tokenTokenID)
            prio = tokenOfResults.tokens[i].priority;

        for(var i in token)
        {
          if(i != "token")
          {
            for(var j in token[i])
            {
              nbElm++;
            }
          }
        }

        return prio*nbElm;
      },

      _computeTokenCoverage: function(nbToken)
      {
        return nbToken/this.tokensOfResult.length;
      },

      _resetResultArray: function(array)
      {
        array = null;
        array = [];
      },
      _updateResultArray: function(resultArray, nbToken, id, type, priorityScore)
      {
        // this.push('resultArray', {"nbTokenAns"  : nbToken, "priorityScore": priorityScore,"id": id.split("#")[1], "trueID": id, "type": type.split("/")[type.split("/").length-1]});
        resultArray.push({"nbTokenAns"  : nbToken, "priorityScore": priorityScore,"id": id.split("#")[1], "trueID": id, "type": type.split("/")[type.split("/").length-1]});

        // var arr = this.resultArray;
        // this.resultArray = [];
        // this.resultArray = arr;
      },

      _symbolTrad: function(symbol)
      {
        switch (symbol) {
          case "K":
            return "knowledge";
          case "O":
            return "objective";
          case "N":
            return "name";
          case "A":
            return "addendum";
          case "G":
            return "graph of concept";
          case "B":
            return "behaviour of the operation";
          case "I":
            return "input";
          case "IB":
            return "input of the operation";
          case "C":
            return "context";
          default:
            return "unknown element";
        }
      },

      _constructHtmlOfStep : function(parents, stepCurrent, token, matching)
      {
        var tmpHtml = " in the steps: <ul>";
        var parent;
        var otherReason = false;

        for(var stepID in stepCurrent)
        {
          tmpHtml += "<li>"+stepCurrent[stepID].current+" because in it:<ul>";

          parent = parents[stepCurrent[stepID].current];

          if(parent)
          {
            for(var token in parent)
            {
              if(token != "nbTokenAnswered" && token != "type")
              {
                tmpHtml += "<li>the token ("+token+") has been found:"
                if(parent[token][matching])
                {
                  tmpHtml += "<ul>";
                  for(var symbol in parent[token][matching])
                  {
                    tmpHtml += "<li>";
                    for(var element in parent[token][matching][symbol])
                    {
                      if(otherReason)
                        tmpHtml += ", but also ";

                      tmpHtml += " in the "+this._symbolTrad(symbol)+" of "+stepCurrent[stepID].current+" via "+parent[token][matching][symbol][element].current;
                      otherReason = true;
                    }
                    otherReason = false;
                    tmpHtml += "</li>";
                  }
                  tmpHtml += "</ul>";
                }
                // tmpHtml += "The token (0) has been found in the (knowledge) of "+id+"(, but also in its (name))".
                // tmpHtml += "The token 2 has been found in the (step) of "+id+", because in it, one graph contains the token".
                tmpHtml += "</li>";
              }
            }
          }

          tmpHtml += "</ul></li>";

          }

          tmpHtml+= "</ul>";

        return tmpHtml
      },

      _howManyTokensAnswered : function(aParent)
      {
        var list = {nb:0, tokens: [], tokensID: []};
        for(var i in aParent)
        {
          if(i != "type" && i != "nbTokenAnswered")
          {
            list.nb++;
            list.tokens.push(aParent[i].token);
            list.tokensID.push(aParent[i].token.token.id);
          }
        }

        return list;
      },

      _testCascading: function(r)
      {
        console.log(r);
      },


    });
  </script>
</dom-module>
