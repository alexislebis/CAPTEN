<link rel="import" href="../../../import/zebra-import.html">

<dom-module id="searching-according-need-element">
  <template>
    <style>

    </style>

    Dim = [Objectif,Need,Context]
    Describe Need <extended-paper-input-element id="need" vocab="{{vocab}}" customcls="{{customcls}}" customprops="{{customprops}}" label="Need description, N = (t1, t2,...,tn)" value="{{need}}" char-counter required></extended-paper-input-element>


      <p>degree validity by user</p>

      <template is="dom-if" if="{{fuzzyChecked}}" restamp="true">
        modificator
        <paper-dropdown-menu label="fuzzyModification" name="fuzzyModification" required>
            <paper-menu class="dropdown-content" id="fuzzyDropdown">
                <paper-item value="">No modificator</paper-item>
                <paper-item value="">Extremely</paper-item>
                <paper-item value="">Very</paper-item>
                <paper-item value="">Pretty</paper-item>
                <paper-item value="">Somewhat</paper-item>
                <paper-item value="">Badly</paper-item>
                <paper-item value="">Not</paper-item>
            </paper-menu>
        </paper-dropdown-menu>

        <paper-dropdown-menu label="typeOfSimilarity" name="typeOfSimilarity" required>
            <paper-menu class="dropdown-content" id="similarityDropdown">
                <paper-item value="">Similar</paper-item>
                <paper-item value="">Assimilable</paper-item>
                <paper-item value="">Approximating</paper-item>
                <paper-item value="">Alike</paper-item>
                <paper-item value="">Equivalent</paper-item>
                <paper-item value="">Identical</paper-item>
                <paper-item value="">Nearby</paper-item>
                <paper-item value="">Different</paper-item>
            </paper-menu>
        </paper-dropdown-menu>

        to my need description.

      </template>

    <h3>Matching behaviors</h3>
      <paper-checkbox checked="{{semanticChecked}}">Semantic matching</paper-checkbox>
      <paper-checkbox checked="{{fuzzyChecked}}">Fuzzy matching</paper-checkbox>


    <paper-button raised on-click="_startSearch">Let's match</paper-button>

    <h3>Result display</h3>
      <div id="result">

      </div>
  </template>
  <script>
    Polymer({
      is: "searching-according-need-element",

      properties:
      {
        fuzzyChecked:
        {
          type: Boolean,
          value: true,
          notify: true,
        },

        semanticChecked:
        {
          type: Boolean,
          value: true,
          notify: true,
        },
        vocab:
        {
          type: Object,
        },
        customcls://used for file-reader
        {
            type: Array,
            notify: true,
        },
        customprops:
        {
            type: Array,
            notify: true,
        },
        need:
        {
          type: Object,//ExtendedString
          notify: true,
        }
      },

      observers:
      [

      ],


      _startSearch: function()
      {
        var mapDimTerms = [];
        if(this.need && this.need.getString().length > 0)
        {
          mapDimTerms["need"] = this.need.getSpecialElements();
        }

        SEARCH_ENGINE.execute(mapDimTerms).then(
          function(resolve)
          {
            this._updateHTML(resolve);
          }.bind(this)
        );

        // if(!HYLAR_HANDLER.isReady())
        //   return;
        //
        // if(this.need && this.need.getString().length > 0)
        // {
        //   mapDimTerms["need"] = this.need.getSpecialElements();
        // }
        //
        // var result = this._defaultSearchBehavior(mapDimTerms);
      },

      _updateHTML: function(resultOfParentRelevancy)
      {
        var html = "<ul>";
        var tmpHtml = "";
        var otherReason = false;
        var analysisHTML = "";
        var otherHTML = "";

        for(var id in resultOfParentRelevancy)
        {
          tmpHtml = "";
          // if(resultOfParentRelevancy[id].type == ANALYSIS_URI)
          // {
            tmpHtml += id +"(a "+resultOfParentRelevancy[id].type+") can be a solution because it solves exactly "+this._howManyTokensAnswered(resultOfParentRelevancy[id]).nb+" tokens ("+this._howManyTokensAnswered(resultOfParentRelevancy[id]).tokensID+") of your described need. ";
            tmpHtml += "<ul>";
            for(var token in resultOfParentRelevancy[id])
            {
              if(token != "nbTokenAnswered" && token != "type")
              {
                tmpHtml += "<li>The token ("+token+") has been found:"
                if(resultOfParentRelevancy[id][token]["perfectMatching"])
                {
                  tmpHtml += "<ul>";
                  for(var symbol in resultOfParentRelevancy[id][token]["perfectMatching"])
                  {
                    tmpHtml += "<li>";
                    if(symbol == "S")
                      tmpHtml += this._constructHtmlOfStep(resultOfParentRelevancy, resultOfParentRelevancy[id][token]["perfectMatching"][symbol], token, "perfectMatching");
                    else
                    {
                      for(var element in resultOfParentRelevancy[id][token]["perfectMatching"][symbol])
                      {
                        if(otherReason)
                          tmpHtml += ", but also ";

                        tmpHtml += " in the "+this._symbolTrad(symbol)+" of "+id+" via "+resultOfParentRelevancy[id][token]["perfectMatching"][symbol][element].current;
                        otherReason = true;
                      }
                    }

                    otherReason = false;
                    tmpHtml += "</li>";
                  }
                  tmpHtml += "</ul>";
                }
                // tmpHtml += "The token (0) has been found in the (knowledge) of "+id+"(, but also in its (name))".
                // tmpHtml += "The token 2 has been found in the (step) of "+id+", because in it, one graph contains the token".
                tmpHtml += "</li>";
              }
            }

            tmpHtml += "</ul>";

            if(resultOfParentRelevancy[id].type == ANALYSIS_URI)
              analysisHTML += "<li>"+tmpHtml+"</li>";
            else
              otherHTML += "<li>"+tmpHtml+"</li>";
          // }


        }

        html += "<h4>ANALYSIS</h4>"+ analysisHTML +"<h4>OTHER ELEMENTS</h4>"+ otherHTML + "</ul>";
        var div = document.createElement('div');
        div.innerHTML = html;
        this.$$('#result').appendChild(div);
        // return html;
      },

      _symbolTrad: function(symbol)
      {
        switch (symbol) {
          case "K":
            return "knowledge";
          case "O":
            return "objective";
          case "N":
            return "name";
          case "A":
            return "addendum";
          case "G":
            return "graph of concept";
          case "B":
            return "behaviour of the operation";
          default:
            return "unknown element";
        }
      },

      _constructHtmlOfStep : function(parents, stepCurrent, token, matching)
      {
        var tmpHtml = " in the steps: <ul>";
        var parent;
        var otherReason = false;

        for(var stepID in stepCurrent)
        {
          tmpHtml += "<li>"+stepCurrent[stepID].current+" because in it:<ul>";

          parent = parents[stepCurrent[stepID].current];

          if(parent)
          {
            for(var token in parent)
            {
              if(token != "nbTokenAnswered" && token != "type")
              {
                tmpHtml += "<li>the token ("+token+") has been found:"
                if(parent[token]["perfectMatching"])
                {
                  tmpHtml += "<ul>";
                  for(var symbol in parent[token]["perfectMatching"])
                  {
                    tmpHtml += "<li>";
                    for(var element in parent[token]["perfectMatching"][symbol])
                    {
                      if(otherReason)
                        tmpHtml += ", but also ";

                      tmpHtml += " in the "+this._symbolTrad(symbol)+" of "+stepCurrent[stepID].current+" via "+parent[token]["perfectMatching"][symbol][element].current;
                      otherReason = true;
                    }
                    otherReason = false;
                    tmpHtml += "</li>";
                  }
                  tmpHtml += "</ul>";
                }
                // tmpHtml += "The token (0) has been found in the (knowledge) of "+id+"(, but also in its (name))".
                // tmpHtml += "The token 2 has been found in the (step) of "+id+", because in it, one graph contains the token".
                tmpHtml += "</li>";
              }
            }
          }

          tmpHtml += "</ul></li>";

          // for(var cur in stepCurrent[stepID])
          // {
          //     tmpHtml += "The token ("+token+") has been found"
          //     if(stepCurrent[stepID][token][matching])
          //     {
          //       for(var symbol in stepCurrent[stepID][token][matching])
          //       {
          //         for(var element in stepCurrent[stepID][token][matching][symbol])
          //         {
          //           if(otherReason)
          //             tmpHtml += ", but also ";
          //
          //           tmpHtml += "in the "+symbol+" of "+id+" via "+stepCurrent[stepID][token][matching][symbol][element].current;
          //         }
          //       }
          //     }
          }

          tmpHtml+= "</ul>";

        return tmpHtml
      },

      _howManyTokensAnswered : function(aParent)
      {
        var list = {nb:0, tokens: [], tokensID: []};
        for(var i in aParent)
        {
          if(i != "type" && i != "nbTokenAnswered")
          {
            list.nb++;
            list.tokens.push(aParent[i].token);
            list.tokensID.push(aParent[i].token.token.id);
          }
        }

        return list;
      },

      // _defaultSearchBehavior: function(mapDimTerms)
      // {
      //   if(mapDimTerms["need"])
      //     this._searchNeed(mapDimTerms["need"]);
      // },
      //
      // // == NEED SEARCHING
      //   _searchNeed: async function(needTerms)
      //   {
      //     console.log("looking for : "+needTerms[0]);
      //
      //     var resultOrganizer = [];
      //     // = = = Looking into name elements
      //       // query = "SELECT * WHERE { ?s <http://www.CAPTEN.org/SEED/ontologies/hasName> ?obj . ?obj <http://www.CAPTEN.org/SEED/ontologies/hasContent> ?content . ?content <http://www.w3.org/1999/02/22-rdf-syntax-ns#li> ?e . ?e <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //       var query = "SELECT * WHERE { ?s <http://www.CAPTEN.org/SEED/ontologies/hasName> ?obj . ?obj <http://www.w3.org/1999/02/22-rdf-syntax-ns#li> ?e . ?e <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //
      //       // HYLAR_HANDLER.queryOnto(query, [this, this._afterNeedQueries]);
      //       var elm = await HYLAR_HANDLER.promiseToQueryOnto(query);
      //
      //       var sortedRes = await this._sortingByType(elm, "s");
      //
      //       resultOrganizer[NAME_URI] = elm;
      //       resultOrganizer[NAME_URI] = sortedRes[0];
      //       resultOrganizer[NAME_URI] = "NAME_WEIGHTING";
      //     // = = =
      //
      //     // = = = SEARCHING INTO OBJECTIVE
      //       query = "SELECT * WHERE { ?s <http://www.CAPTEN.org/SEED/ontologies/hasName> ?obj . ?obj <http://www.CAPTEN.org/SEED/ontologies/hasContent> ?content . ?content <http://www.w3.org/1999/02/22-rdf-syntax-ns#li> ?e . ?e <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //
      //       elm = await HYLAR_HANDLER.promiseToQueryOnto(query);
      //       sortedRes = await this._sortingByType(elm, "s");
      //
      //       resultOrganizer[OBJECTIVE_URI] = elm;
      //       resultOrganizer[OBJECTIVE_URI] = sortedRes[0];
      //       resultOrganizer[OBJECTIVE_URI] = "weight";
      //     // = = =
      //     // = = = SEARCHING INTO GRAPHS
      //       // Warning ; consider the case of node reported to a G1 to G2 automatically, the creation step, etc..
      //       query = "SELECT * WHERE { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.CAPTEN.org/SEED/ontologies/RGTE>. ?s <http://www.CAPTEN.org/SEED/ontologies/hasVariable> ?v . ?v <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //
      //       elm = await HYLAR_HANDLER.promiseToQueryOnto(query);
      //       sortedRes = await this._sortingByType(elm, "s");
      //
      //       resultOrganizer[RGTE_URI] = elm;
      //       resultOrganizer[RGTE_URI] = sortedRes[0];
      //       resultOrganizer[RGTE_URI] = "weigth";
      //     // = = =
      //
      //     // = = = SEARCHING INTO ADDENDUM (using subsumption prop to retrieve any descr.)
      //       query = "SELECT * WHERE { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.CAPTEN.org/SEED/ontologies/Addendum> . ?s <http://www.CAPTEN.org/SEED/ontologies/hasContent> ?content . ?content <http://www.w3.org/1999/02/22-rdf-syntax-ns#li> ?e . ?e <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //       elm = await HYLAR_HANDLER.promiseToQueryOnto(query);
      //       sortedRes = await this._sortingByType(elm, "s");
      //
      //       resultOrganizer[ADDENDUM_URI] = elm;
      //       resultOrganizer[ADDENDUM_URI] = sortedRes[0];
      //       resultOrganizer[ADDENDUM_URI] = "weight";
      //     // = = =
      //
      //     // = = = SEARCHING INTO K
      //       query = "SELECT * WHERE { ?a <http://www.CAPTEN.org/SEED/ontologies/custom/knowledgeGeneratedBy> ?k . ?k <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <"+needTerms[0].getIRI()+"> .}";
      //       elm = await HYLAR_HANDLER.promiseToQueryOnto(query);
      //       //No need to sort (the data struc is ok)
      //       // sortedRes = await this._sortingByType(elm, )
      //
      //       resultOrganizer[KNOWLEDGE_URI] = elm;
      //       resultOrganizer[KNOWLEDGE_URI] = ["NO NEED TO SORT"];
      //       resultOrganizer[KNOWLEDGE_URI] = "weight";
      //     // = = =
      //
      //     console.log(sortedRes);
      //     console.log("REMINDER| Improve queries by using similar property. ?x similar ?y. ?s ?p ?o. ?o type ?x OR ?y.");
      //
      //   },
      //
      //   _afterNeedQueries: function(queriesResults)
      //   {
      //     console.log(queriesResults);
      //     // this._sortingByType(queriesResults, "s");
      //   },
      //
      // // == == == ==
      //
      // // sort by looking type. Result array is the result from a querry handled
      // //by HYLAR_HANDLER.query and sourceID represent what has to be tested (such as ?source ).
      // //return an array containing two array: one a mapped sorting of result according to sourceID, other the direct results
      // _sortingByType: async function(resultArray, sourceID)
      // {
      //   return new Promise(
      //     async function(resolve, reject)
      //     {
      //       if(!resultArray || resultArray.length <= 0)
      //       {
      //         let a = []; a.push([]); a.push([]);
      //         resolve(a);
      //       }
      //
      //       var headQuery = "SELECT ?type WHERE {<";
      //       var tailQuery = "> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> ?type .}";
      //       var queries = [];
      //       var results = [];
      //
      //       for(var i in resultArray)
      //       {
      //         if(resultArray[i][sourceID])
      //         {
      //           var tmp = await HYLAR_HANDLER.promiseToQueryOnto(headQuery+resultArray[i][sourceID].value+tailQuery);
      //
      //           for(var j in tmp)
      //           {
      //             tmp[j][sourceID] = resultArray[i][sourceID];
      //             results.push(tmp[j]);
      //           }
      //         }
      //           // queries.push(headQuery+resultArray[i][sourceID].value+tailQuery);
      //       }
      //
      //       // MAPPING
      //       var map = [];
      //       for(var i in results)
      //       {
      //         if(!map[results[i][sourceID].value])
      //           map[results[i][sourceID].value] = [];
      //
      //         for(var j in results[i])
      //         {
      //           if(results[i][j].value != results[i][sourceID].value)
      //           {
      //             //Prevent duplicata during insertion
      //             var alreadyExist = false;
      //             for(var k in map[results[i][sourceID].value])
      //             {
      //               if(map[results[i][sourceID].value][k] == results[i][j].value)
      //                 alreadyExist = true;
      //
      //               if(alreadyExist)
      //                 break;
      //             }
      //             if(!alreadyExist)
      //               map[results[i][sourceID].value].push(results[i][j].value);
      //           }
      //         }
      //       }
      //
      //       var endResults = []; endResults.push(map); endResults.push(results);
      //
      //       // HYLAR_HANDLER.cascadingQueryOnto(queries, [], [this, this._testCascading]);
      //       resolve(endResults);
      //     }
      //   )
      // },

      _testCascading: function(r)
      {
        console.log(r);
      },


    });
  </script>
</dom-module>
